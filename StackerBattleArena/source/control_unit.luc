module control_unit (
    input clk,
    input rst,
    input clk_game,
    input clk_oscillate,
    input r0[32],        // R0 row height register
    input rd1[32],       // RD1 regfile addressable register
    input action_btn,    // Action button that is already debounced and rising edge only
    input shift_ok[4],   // special 4-bit indicator to indicate at what point are the squares ok to shift on the screen
    output rowshft[6],   // combinational output of how many rows to shift for display buffer
    output rowreg[5],    // combinational output of the correct row register for a specific row in the display buffer. 
                         // NOTE: Please check regfile for the correct mapping of display registers!!!!
    output rowmask[32],
    output rxc,          // display buffer clear
    output ra1[4],       // register read address 1
    output ra2[4],       // register read address 2
    output wa[4],        // register write address
    output we,           // register write enable
    output alufn[6],     // ALU function
    output asel[3],
    output bsel[3],
    output wdsel,
    
    // Serial port
    output new_tx,     // new TX flag
    output tx_data[8], // TX data
    input tx_busy      // TX is busy flag
) {
    // State Machine
    enum States {
        MENU_START_00, 
        
        GAME_START_1_01, 
        GAME_START_2_02, 
        GAME_START_3_03,
        GAME_START_4_04,
        GAME_START_5_05,
        
        GAME_IDLE_06,
        GAME_SHFT_BLK_07,
        GAME_SHFT_BLK2_08,
        GAME_SHFT_BLK3_09,
        GAME_SHFT_10,
        
        GAME_STORE1_11,
        GAME_STORE2_12,
        
        GAME_DRAW1_13,
        GAME_DRAW2_14,
        GAME_DRAW3_15,
        GAME_DRAW4_16,
        GAME_DRAW5_17,
        
        GAME_ACTION_18,
        GAME_ACTION2_19,
        GAME_ACTION3_20,
        GAME_ACTION4_21,
        GAME_ACTION5_22,
        
        DEBUG
    }

    sig rowshft_x[6]
    sig rowreg_x[4]
    
    // Serial debugger
    const BUFFER_LEN = 149
    const DEBUG_ENABLED = 1
    bin_to_hex_ascii bin2hex()
    
    .clk(clk) {
        .rst(rst) {
            dff toPrintDebug(#INIT(DEBUG_ENABLED)) // 1 means need to print debug statement. debug should only be printed once per state!
            dff state[$width(States)](#INIT(States.MENU_START_00)) // actual state
            dff currState[$width(States)](#INIT(States.MENU_START_00)) // current state (without debug transitions)
            
            // Output registers
            dff alufn_x[6](#INIT(0))
            dff asel_x[3](#INIT(0))
            dff bsel_x[3](#INIT(0))
            dff wa_x[4](#INIT(0))
            dff we_x(#INIT(0))
            dff wdsel_x(#INIT(0))
            dff rxc_x(#INIT(0))
            dff ra1_x[4](#INIT(0))
            dff ra2_x[4](#INIT(0))
            
            // Serial debugger
            dff count[$clog2(BUFFER_LEN)](#INIT(0)) // buffer counter
        }
    }
    
    always {
        state.d = state.q
        currState.d = currState.q
        new_tx = 0
        bin2hex.bin = 0
        
        // Prevent partially driven outputs
        rxc = 0
        ra1_x.d = ra1_x.q
        ra2_x.d = ra2_x.q
        wa_x.d = wa_x.q
        we_x.d = we_x.q
        alufn_x.d = alufn_x.q
        asel_x.d = asel_x.q
        bsel_x.d = bsel_x.q
        wdsel_x.d = wdsel_x.q
        rxc_x.d = rxc_x.q
        
        // LUT for ROWSHFT and ROWREG logic
        // transform R0 row height register into the correct display buffer register
        case (r0) {
            default: rowreg_x = 8; rowshft_x = 0
            1: rowreg_x = 8; rowshft_x = 0 //NOTE: row height of 1 is the real first row, as our rows are 1-indexed
            2: rowreg_x = 8; rowshft_x = 8
            3: rowreg_x = 8; rowshft_x = 16
            4: rowreg_x = 8; rowshft_x = 24
            5: rowreg_x = 9; rowshft_x = 0
            6: rowreg_x = 9; rowshft_x = 8
            7: rowreg_x = 9; rowshft_x = 16
            8: rowreg_x = 9; rowshft_x = 24
            9: rowreg_x = 10; rowshft_x = 0
            10: rowreg_x = 10; rowshft_x = 8
            11: rowreg_x = 10; rowshft_x = 16
            12: rowreg_x = 10; rowshft_x = 24
            13: rowreg_x = 11; rowshft_x = 0
            14: rowreg_x = 11; rowshft_x = 8
            15: rowreg_x = 11; rowshft_x = 16
            16: rowreg_x = 11; rowshft_x = 24
        }
        rowshft = rowshft_x
        rowreg = rowreg_x

        // LUT for ROWMASK logic
        case (rowshft_x) {
            0: rowmask = h000000FF
            8: rowmask = h0000FF00
            16: rowmask = h00FF0000
            24: rowmask = hFF000000
            default: rowmask = 0
        }
        
        // Wiring outputs
        asel = asel_x.q
        bsel = bsel_x.q
        we = we_x.q
        wa = wa_x.q
        alufn = alufn_x.q
        wdsel = wdsel_x.q
        rxc = rxc_x.q
        ra1 = ra1_x.q
        ra2 = ra2_x.q
        
        // Serial debugger literals and data conversions
        // Leave blank entry for space character
        // NOTE: during debugging, registers will only take effect upon the NEXT clock cycle
        case (count.q) {
            0: tx_data = "S"
            1: tx_data = "t"
            2: tx_data = "a"
            3: tx_data = "t"
            4: tx_data = "e"
            5: tx_data = ":"
            6: bin2hex.bin = currState.q[4]; tx_data = bin2hex.out;
            7: bin2hex.bin = currState.q[3:0]; tx_data = bin2hex.out;
            8: tx_data = "\n"
            9: tx_data  = "r"
            10: tx_data = "a"
            11: tx_data = "1"
            12: tx_data = ":"
            
            13: bin2hex.bin = ra1_x.q; tx_data = bin2hex.out;
            14: tx_data = "\n"
            15: tx_data  = "r"
            16: tx_data = "a"
            17: tx_data = "2"
            18: tx_data = ":"
            
            20: bin2hex.bin = ra2_x.q; tx_data = bin2hex.out;
            21: tx_data = "\n"
            22: tx_data  = "r"
            23: tx_data = "x"
            24: tx_data = "c"
            25: tx_data = ":"
            
            27: bin2hex.bin = rxc_x.q; tx_data = bin2hex.out;
            28: tx_data = "\n"
            29: tx_data  = "a"
            30: tx_data = "s"
            31: tx_data = "e"
            32: tx_data = "l"
            33: tx_data = ":"
            
            34: bin2hex.bin = asel_x.q; tx_data = bin2hex.out;
            35: tx_data = "\n"
            36: tx_data  = "b"
            37: tx_data = "s"
            38: tx_data = "e"
            39: tx_data = "l"
            40: tx_data = ":"
            
            42: bin2hex.bin = bsel_x.q; tx_data = bin2hex.out;
            43: tx_data = "\n"
            44: tx_data  = "w"
            45: tx_data = "e"
            46: tx_data = ":"
            
            48: bin2hex.bin = we_x.q; tx_data = bin2hex.out;
            49: tx_data = "\n"
            50: tx_data  = "w"
            51: tx_data = "a"
            52: tx_data = ":"
            
            54: bin2hex.bin = wa_x.q; tx_data = bin2hex.out;
            55: tx_data = "\n"
            56: tx_data = "w"
            57: tx_data = "d"
            58: tx_data = "s"
            59: tx_data = "e"
            60: tx_data = "l"
            61: tx_data = ":"
            
            63: bin2hex.bin = wdsel_x.q; tx_data = bin2hex.out;
            64: tx_data = "\n"
            65: tx_data = "a"
            66: tx_data = "l"
            67: tx_data = "u"
            68: tx_data = "f"
            69: tx_data = "n"
            70: tx_data = ":"
            
            72: bin2hex.bin = alufn_x.q[5:4]; tx_data = bin2hex.out;
            73: bin2hex.bin = alufn_x.q[3:0]; tx_data = bin2hex.out;
            74: tx_data = "\n"
            75: tx_data = "r"
            76: tx_data = "o"
            77: tx_data = "w"
            78: tx_data = "r"
            79: tx_data = "e"
            80: tx_data = "g"
            81: tx_data = ":"
            
            83: bin2hex.bin = rowreg_x; tx_data = bin2hex.out;
            84: tx_data = "\n"
            85: tx_data = "r"
            86: tx_data = "o"
            87: tx_data = "w"
            88: tx_data = "s"
            89: tx_data = "h"
            90: tx_data = "f"
            91: tx_data = "t"
            92: tx_data = ":"
            
            94: bin2hex.bin = rowshft_x[5:4]; tx_data = bin2hex.out;
            95: bin2hex.bin = rowshft_x[3:0]; tx_data = bin2hex.out;
            
            96: tx_data = "\n"
            97: tx_data = "-"
            98: tx_data = "-"
            99: tx_data = "-"
            100: tx_data = "-"
            101: tx_data = "-"
            102: tx_data = "-"
            103: tx_data = "-"
            104: tx_data = "-"
            105: tx_data = "-"
            106: tx_data = "-"
            107: tx_data = "-"
            108: tx_data = "\n"
            109: tx_data = "r"
            110: tx_data = "0"
            111: tx_data = ":"
            
            113: bin2hex.bin = r0[31:28]; tx_data = bin2hex.out;
            114: bin2hex.bin = r0[27:24]; tx_data = bin2hex.out;
            115: bin2hex.bin = r0[23:20]; tx_data = bin2hex.out;
            116: bin2hex.bin = r0[19:16]; tx_data = bin2hex.out;
            117: bin2hex.bin = r0[15:12]; tx_data = bin2hex.out;
            118: bin2hex.bin = r0[11:8]; tx_data = bin2hex.out;
            119: bin2hex.bin = r0[7:4]; tx_data = bin2hex.out;
            120: bin2hex.bin = r0[3:0]; tx_data = bin2hex.out;
            121: tx_data = "\n"
            122: tx_data = "r"
            123: tx_data = "d"
            124: tx_data = "1"
            125: tx_data = ":"
            
            127: bin2hex.bin = rd1[31:28]; tx_data = bin2hex.out;
            128: bin2hex.bin = rd1[27:24]; tx_data = bin2hex.out;
            129: bin2hex.bin = rd1[23:20]; tx_data = bin2hex.out;
            130: bin2hex.bin = rd1[19:16]; tx_data = bin2hex.out;
            131: bin2hex.bin = rd1[15:12]; tx_data = bin2hex.out;
            132: bin2hex.bin = rd1[11:8]; tx_data = bin2hex.out;
            133: bin2hex.bin = rd1[7:4]; tx_data = bin2hex.out;
            134: bin2hex.bin = rd1[3:0]; tx_data = bin2hex.out;
            135: tx_data = "\n"
            136: tx_data = "="
            137: tx_data = "="
            138: tx_data = "="
            139: tx_data = "="
            140: tx_data = "="
            141: tx_data = "="
            142: tx_data = "="
            143: tx_data = "="
            144: tx_data = "="
            145: tx_data = "="
            146: tx_data = "="
            147: tx_data = "="
            148: tx_data = "\n"
            149: tx_data = "\n"

            default: bin2hex.bin = 0; tx_data = " "
        }
        
        // State machine
        case (state.q) {
            States.MENU_START_00:
                // NOP()
                alufn_x.d = bxxxxxx
                asel_x.d = bxxx
                ra1_x.d = bxxxx
                ra2_x.d = bxxxx
                bsel_x.d = bxx
                we_x.d = 0
                wa_x.d = bxxxx
                wdsel_x.d = 1
                rxc_x.d = 0
                
                // Debug stub and state transitions
                count.d = 0
                if (toPrintDebug.q) {
                    currState.d = States.MENU_START_00
                    state.d = States.DEBUG
                }
                else if (action_btn) {
                    toPrintDebug.d = DEBUG_ENABLED
                    state.d = States.GAME_START_1_01
                }
                
            States.GAME_START_1_01:
                // STORE_LITERAL (ASEL=2, WA=R0)
                /*
                    ALUFN = “A”		(let ALU pass through input A to output)
                    ASEL = ASEL
                    RA1 = x
                    RA2 = x
                    BSEL = x
                    WE = 1		(enable write to RegFile)
                    WA = WA		(write to register defined by WA)
                    WDSEL = 0		(write from ALU output)
                    RXC=0
                */
                
                alufn_x.d = b011010
                asel_x.d = 2 // set r0 to 1
                ra1_x.d = 0
                ra2_x.d = 0
                bsel_x.d = 0
                we_x.d = 1
                wa_x.d = 0 // R0
                wdsel_x.d = 0
                rxc_x.d = 0
                
                // Debug stub and state transitions
                count.d = 0
                if (toPrintDebug.q) {
                    currState.d = States.GAME_START_1_01
                    state.d = States.DEBUG
                } else {
                    toPrintDebug.d = DEBUG_ENABLED
                    state.d = States.GAME_START_2_02
                }
            
            States.GAME_START_2_02:
                // STORE_LITERAL (ASEL=3, WA=R1)
                /*
                    ALUFN = “A”		(let ALU pass through input A to output)
                    ASEL = ASEL
                    RA1 = x
                    RA2 = x
                    BSEL = x
                    WE = 1		(enable write to RegFile)
                    WA = WA		(write to register defined by WA)
                    WDSEL = 0		(write from ALU output)
                    RXC=0
                */
                
                alufn_x.d = b011010
                asel_x.d = 3 // set r1 to 0xf
                ra1_x.d = 0
                ra2_x.d = 0
                bsel_x.d = 0
                we_x.d = 1
                wa_x.d = 1 // R1
                wdsel_x.d = 0
                rxc_x.d = 0
                
                // Debug stub and state transitions
                count.d = 0
                if (toPrintDebug.q) {
                    currState.d = States.GAME_START_2_02
                    state.d = States.DEBUG
                }
                else {
                    toPrintDebug.d = DEBUG_ENABLED
                    state.d = States.GAME_START_3_03
                }
            
            States.GAME_START_3_03:
                //CLEAR_DISP ()
                /*
                    ALUFN = x
                    ASEL = x
                    RA1 = x
                    RA2 = x
                    BSEL = x
                    WE = 0		(disable write to RegFile)
                    WA = x
                    WDSEL = 1		(0 literal)
                    RXC=1
                */
                
                alufn_x.d = bxxxxxx
                asel_x.d = bxxx
                ra1_x.d = bxxxx
                ra2_x.d = bxxxx
                bsel_x.d = bxx
                we_x.d = 0
                wa_x.d = bxxxx // R1
                wdsel_x.d = 1
                rxc_x.d = 1
            
                // Debug stub and state transitions
                count.d = 0
                if (toPrintDebug.q) {
                    currState.d = States.GAME_START_3_03
                    state.d = States.DEBUG
                }
                else {
                    toPrintDebug.d = DEBUG_ENABLED
                    state.d = States.GAME_START_4_04
                }
            
            States.GAME_START_4_04:
                // STORE_LITERAL (ASEL=3, WA=RX0/R8)
                /*
                    ALUFN = “A”		(let ALU pass through input A to output)
                    ASEL = ASEL
                    RA1 = x
                    RA2 = x
                    BSEL = x
                    WE = 1		(enable write to RegFile)
                    WA = WA		(write to register defined by WA)
                    WDSEL = 0		(write from ALU output)
                    RXC=0
                */
                alufn_x.d = b011010
                asel_x.d = 3 // set r8 / rx0 to 0xf
                ra1_x.d = 0
                ra2_x.d = 0
                bsel_x.d = 0
                we_x.d = 1
                wa_x.d = 8 // R8
                wdsel_x.d = 0
                rxc_x.d = 0
            
                // Debug stub and state transitions
                count.d = 0
                if (toPrintDebug.q) {
                    currState.d = States.GAME_START_4_04
                    state.d = States.DEBUG
                }
                else {
                    toPrintDebug.d = DEBUG_ENABLED
                    state.d = States.GAME_START_5_05
                }
            
            States.GAME_START_5_05:
                // STORE_LITERAL (ASEL=4, WA=R6)
                /*
                    ALUFN = “A”		(let ALU pass through input A to output)
                    ASEL = ASEL
                    RA1 = x
                    RA2 = x
                    BSEL = x
                    WE = 1		(enable write to RegFile)
                    WA = WA		(write to register defined by WA)
                    WDSEL = 0		(write from ALU output)
                    RXC=0
                */
                alufn_x.d = b011010
                asel_x.d = 4 // set r6 to 0xff
                ra1_x.d = 0
                ra2_x.d = 0
                bsel_x.d = 0
                we_x.d = 1
                wa_x.d = 6 // R6
                wdsel_x.d = 0
                rxc_x.d = 0
            
                // Debug stub and state transitions
                count.d = 0
                if (toPrintDebug.q) {
                    currState.d = States.GAME_START_5_05
                    state.d = States.DEBUG
                }
                else {
                    toPrintDebug.d = DEBUG_ENABLED
                    state.d = States.GAME_IDLE_06
                }
            
            States.GAME_IDLE_06:
                // NOP()
                alufn_x.d = bxxxxxx
                asel_x.d = bxxx
                ra1_x.d = bxxxx
                ra2_x.d = bxxxx
                bsel_x.d = bxx
                we_x.d = 0
                wa_x.d = bxxxx
                wdsel_x.d = 1
                rxc_x.d = 0
                
                // Debug stub and state transitions
                count.d = 0
                if (toPrintDebug.q) {
                    currState.d = States.GAME_IDLE_06
                    state.d = States.DEBUG
                }
                else if (clk_game) {
                    toPrintDebug.d = DEBUG_ENABLED
                    state.d = States.GAME_DRAW1_13
                }
                else if (clk_oscillate) {
                    toPrintDebug.d = DEBUG_ENABLED
                    state.d = States.GAME_SHFT_BLK_07
                } else if (action_btn) {
                    toPrintDebug.d = DEBUG_ENABLED
                    state.d = States.GAME_ACTION_18
                }
            
            States.GAME_SHFT_BLK_07:
                // NOP()
                alufn_x.d = bxxxxxx
                asel_x.d = bxxx
                ra1_x.d = bxxxx
                ra2_x.d = bxxxx
                bsel_x.d = bxx
                we_x.d = 0
                wa_x.d = bxxxx
                wdsel_x.d = 1
                rxc_x.d = 0
                
                // Debug stub and state transitions
                count.d = 0
                if (toPrintDebug.q) {
                    currState.d = States.GAME_SHFT_BLK_07
                    state.d = States.DEBUG
                } else {
                    toPrintDebug.d = DEBUG_ENABLED
                    case (shift_ok) {
                        b1000: // ok to shift left
                            state.d = States.GAME_SHFT_BLK2_08
                        b0100: // ok to shift right
                            state.d = States.GAME_SHFT_BLK3_09
                        b0010: // not ok to shift left, change to shift right
                            state.d = States.GAME_STORE1_11
                        b0001: // not ok to shift right, change to shift left
                            state.d = States.GAME_STORE2_12
                        // default is intentionally omitted as the program should hang here for debug if weird things happen
                    }
                }
                
            States.GAME_SHFT_BLK2_08:
                // SHIFT_1(ALUFN=SHL)
                /*
                    ALUFN = ALUFN	(either shift left or right)
                    ASEL = 0		(RD1)
                    RA1 = R1
                    RA2 = x
                    BSEL = 2		(1 literal)
                    WE = 1		(enable write to RegFile)
                    WA = R4
                    WDSEL = 0		(ALU output)
                    RXC=0
                */
                alufn_x.d = b100000 // SHL
                asel_x.d = 0
                ra1_x.d = 1
                ra2_x.d = bxxxx
                bsel_x.d = 2 // 1 literal
                we_x.d = 1
                wa_x.d = 4    // write SHL of R1 by 1 into R4
                wdsel_x.d = 0
                rxc_x.d = 0
            
                // Debug stub and state transitions
                count.d = 0
                if (toPrintDebug.q) {
                    currState.d = States.GAME_SHFT_BLK2_08
                    state.d = States.DEBUG
                }
                else {
                    toPrintDebug.d = DEBUG_ENABLED
                    state.d = States.GAME_SHFT_10
                }
            
            States.GAME_SHFT_BLK3_09:
                // SHIFT_1(ALUFN=SHR)
                /*
                    ALUFN = ALUFN	(either shift left or right)
                    ASEL = 0		(RD1)
                    RA1 = R1
                    RA2 = x
                    BSEL = 2		(1 literal)
                    WE = 1		(enable write to RegFile)
                    WA = R4
                    WDSEL = 0		(ALU output)
                    RXC=0
                */
                alufn_x.d = b100001 // SHR
                asel_x.d = 0
                ra1_x.d = 1
                ra2_x.d = bxxxx
                bsel_x.d = 2 // 1 literal
                we_x.d = 1
                wa_x.d = 4    // write SHR of R1 by 1 into R4
                wdsel_x.d = 0
                rxc_x.d = 0
                
                // Debug stub and state transitions
                count.d = 0
                if (toPrintDebug.q) {
                    currState.d = States.GAME_SHFT_BLK3_09
                    state.d = States.DEBUG
                }
                else {
                    toPrintDebug.d = DEBUG_ENABLED
                    state.d = States.GAME_SHFT_10
                }
            
            States.GAME_SHFT_10:
                // SHIFT_2()
                /*
                    ALUFN = “A”		(let ALU pass through input A to output)
                    ASEL = 0		(RD1)
                    RA1 = R4
                    RA2 = x
                    BSEL = x
                    WE = 1		(enable write to RegFile)
                    WA = R1
                    WDSEL = 0		(ALU output)
                    RXC=0
                */
                alufn_x.d = b011010
                asel_x.d = 0
                ra1_x.d = 4
                ra2_x.d = bxxxx
                bsel_x.d = bxx
                we_x.d = 1
                wa_x.d = 1    // write contents of R4 into R1
                wdsel_x.d = 0
                rxc_x.d = 0
            
                // Debug stub and state transitions
                count.d = 0
                if (toPrintDebug.q) {
                    currState.d = States.GAME_SHFT_10
                    state.d = States.DEBUG
                }
                else {
                    toPrintDebug.d = DEBUG_ENABLED
                    state.d = States.GAME_IDLE_06
                }
            
            States.GAME_STORE1_11:
                // STORE_LITERAL(ASEL = 2, WA = R3)
                /*
                    ALUFN = “A”		(let ALU pass through input A to output)
                    ASEL = ASEL
                    RA1 = x
                    RA2 = x
                    BSEL = x
                    WE = 1		(enable write to RegFile)
                    WA = WA		(write to register defined by WA)
                    WDSEL = 0		(write from ALU output)
                    RXC=0
                */
                alufn_x.d = b011010
                asel_x.d = 2 // set R3, the direction bit to 1 (shift right)
                ra1_x.d = 0
                ra2_x.d = 0
                bsel_x.d = 0
                we_x.d = 1
                wa_x.d = 3 // R3
                wdsel_x.d = 0
                rxc_x.d = 0
                
                // Debug stub and state transitions
                count.d = 0
                if (toPrintDebug.q) {
                    currState.d = States.GAME_STORE1_11
                    state.d = States.DEBUG
                }
                else {
                    toPrintDebug.d = DEBUG_ENABLED
                    state.d = States.GAME_IDLE_06
                }
                
            States.GAME_STORE2_12:
                // STORE_LITERAL(ASEL = 1, WA = R3)
                /*
                    ALUFN = “A”		(let ALU pass through input A to output)
                    ASEL = ASEL
                    RA1 = x
                    RA2 = x
                    BSEL = x
                    WE = 1		(enable write to RegFile)
                    WA = WA		(write to register defined by WA)
                    WDSEL = 0		(write from ALU output)
                    RXC=0
                */
                alufn_x.d = b011010
                asel_x.d = 1 // set R3, the direction bit to 0 (shift left)
                ra1_x.d = 0
                ra2_x.d = 0
                bsel_x.d = 0
                we_x.d = 1
                wa_x.d = 3 // R3
                wdsel_x.d = 0
                rxc_x.d = 0
                
                // Debug stub and state transitions
                count.d = 0
                if (toPrintDebug.q) {
                    currState.d = States.GAME_STORE2_12
                    state.d = States.DEBUG
                }
                else {
                    toPrintDebug.d = DEBUG_ENABLED
                    state.d = States.GAME_IDLE_06
                }

            States.GAME_DRAW1_13:
                // SHIFT(ALUFN=SHL, RA1=R1, BSEL=3)	// shift the current row in R1 based on ROWSHFT (BSEL=3), and store result in R4 scratch register
                /*
                    ALUFN = SHL/SHR	(either shift left or right)
                    ASEL = 0		(RD1)
                    RA1 = RA1
                    RA2 = x
                    BSEL = BSEL
                    WE = 1		(enable write to RegFile)
                    WA = R4
                    WDSEL = 0		(ALU output)
                    RXC=0
                */
                alufn_x.d = b100000 // SHL R1 by ROWSHFT and store result into R4
                asel_x.d = 0
                ra1_x.d = 1  // R1
                ra2_x.d = 0
                bsel_x.d = 3 // use ROWSHFT input
                we_x.d = 1
                wa_x.d = 4 // R4
                wdsel_x.d = 0
                rxc_x.d = 0

                // Debug stub and state transitions
                count.d = 0
                if (toPrintDebug.q) {
                    currState.d = States.GAME_DRAW1_13
                    state.d = States.DEBUG
                }
                else {
                    toPrintDebug.d = DEBUG_ENABLED
                    state.d = States.GAME_DRAW2_14
                }

            States.GAME_DRAW2_14:
                // XOR (R4,ROWREG,R5)
                // XOR the results of the current row register and the shifted result in the R4 scratch register, 
                // and place it in the R5 scratch register. Equivalent to (x ^ y)
                /*
                    XOR (RA, RB, RC)
                    ALUFN = "XOR"  
                    ASEL = 0       
                    RA1 = RA     
                    RA2 = RB    
                    BSEL = 0
                    WE = 1
                    WA = RC       
                    WDSEL = 0      
                    RXC=0                
                */
                alufn_x.d = b010110 // XOR R4 and ROWREG, place result in R5
                asel_x.d = 0
                ra1_x.d = 4  // R4
                ra2_x.d = rowreg_x
                bsel_x.d = 0
                we_x.d = 1
                wa_x.d = 5 // R5
                wdsel_x.d = 0
                rxc_x.d = 0

                // Debug stub and state transitions
                count.d = 0
                if (toPrintDebug.q) {
                    currState.d = States.GAME_DRAW2_14
                    state.d = States.DEBUG
                }
                else {
                    toPrintDebug.d = DEBUG_ENABLED
                    state.d = States.GAME_DRAW3_15
                }

            States.GAME_DRAW3_15:
                // AND (R5, ROWMASK, R4)	// Equivalent to ((x ^ y) & m). Result stored in R4
                /*
                    ALUFN = "AND"
                    ASEL = 0
                    RA1 = RA
                    RA2 = RB
                    BSEL = 0
                    WE = 1
                    WA = RC
                    WDSEL = 0
                    RXC=0
                */
                alufn_x.d = b011000 // AND R5 and ROWMASK, place result in R4
                asel_x.d = 0
                ra1_x.d = 5  // R5
                ra2_x.d = bxxxx
                bsel_x.d = 5 // use ROWMASK input
                we_x.d = 1
                wa_x.d = 4 // R4
                wdsel_x.d = 0
                rxc_x.d = 0

                // Debug stub and state transitions
                count.d = 0
                if (toPrintDebug.q) {
                    currState.d = States.GAME_DRAW3_15
                    state.d = States.DEBUG
                }
                else {
                    toPrintDebug.d = DEBUG_ENABLED
                    state.d = States.GAME_DRAW4_16
                }
            
            States.GAME_DRAW4_16:
                // XOR (R4, ROWREG, R5)	//Equivalent to x ^ ((x ^ y) & m). Result stored in R5
                alufn_x.d = b010110 // XOR R5 and ROWREG, place result in R4
                asel_x.d = 0
                ra1_x.d = 4  // R4
                ra2_x.d = rowreg_x
                bsel_x.d = 0
                we_x.d = 1
                wa_x.d = 5 // R5
                wdsel_x.d = 0
                rxc_x.d = 0
                
                // Debug stub and state transitions
                count.d = 0
                if (toPrintDebug.q) {
                    currState.d = States.GAME_DRAW4_16
                    state.d = States.DEBUG
                }
                else {
                    toPrintDebug.d = DEBUG_ENABLED
                    state.d = States.GAME_DRAW5_17
                }
            
            States.GAME_DRAW5_17:
                // COPY_REG(R5, ROWREG)
                /*
                    ALUFN = “A”		(let ALU pass through input A to output)
                    ASEL = 0		(RD1)
                    RA1 = RA
                    RA2 = x
                    BSEL = x
                    WE = 1		(enable write to RegFile)
                    WA = RB
                    WDSEL = 0		(ALU output)
                    RXC=0
                */
                alufn_x.d = b010110 // "A"
                asel_x.d = 0
                ra1_x.d = 5 // R5
                ra2_x.d = bxxxx
                bsel_x.d = bxxx
                we_x.d = 1
                wa_x.d = rowreg_x // write R5 to ROWREG
                wdsel_x.d = 0
                rxc_x.d = 0

                // Debug stub and state transitions
                count.d = 0
                if (toPrintDebug.q) {
                    currState.d = States.GAME_DRAW5_17
                    state.d = States.DEBUG
                }
                else {
                    toPrintDebug.d = DEBUG_ENABLED
                    state.d = States.GAME_IDLE_06
                }

            States.DEBUG:
                // print out all control signals within here and jump back to the original state
                toPrintDebug.d = 0
                if (!tx_busy) {
	                   count.d = count.q + 1
	                   new_tx = 1
	                   if (count.q == BUFFER_LEN - 1) {
                        state.d = currState.q
                    }
	               }
            
            default:
                alufn_x.d = b000000
                asel_x.d = 0
                ra1_x.d = b0000
                ra2_x.d = b0000
                bsel_x.d = 0
                we_x.d = 0
                wa_x.d = 0
                wdsel_x.d = 1
                rxc_x.d = 0
                
                if (action_btn) {
                    toPrintDebug.d = DEBUG_ENABLED
                    state.d = States.MENU_START_00
                }
        }
        
    }
}